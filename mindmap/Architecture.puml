@startmindmap
*[#orange] 架构基础\n判断和取舍
    *[#pink] 1架构基础
        *[#lightblue] 架构是什么
            *[#lightgreen] 系统与子系统
                *_ 关联/规则/能力
                *_ level视角不同
            *[#lightgreen] 模块Module与组件Component
                *_ 模块关注业务能力
                *_ 组件关心物理部署
            *[#lightgreen] 框架与架构
                *_ 框架关心规范
                *_ 架构关心结构
            *[#lightgreen] 4R架构
                *_ Rank 层级\n自顶向下,逐级细化
                *_ Role 角色
                *_ Relation 关系
                *_ Rule 协作规则
        *[#lightblue] 架构历史
            *_ 机器语言 1940前
            *_ 汇编语言 40年代
            *_ 高级语言 50年代(Fortran/LISP/Cobol)
            *_ 第一次软件危机60-70年代\n人月神话IBM 360系统 64年\nDijkstra68年提议取消goto
            *_ 第二次软件危机 面向对象80年代
        *[#lightblue] 架构目的
            *_ 解决软件复杂度带来的问题
        *[#lightblue] 复杂度的来源 高性能
            *[#lightgreen] 单机复杂度 操作系统
                *[#lightgrey] 进程
                    *_ 管道/消息队列/信号量/共享存储等
                *[#lightgrey] 线程
                *[#lightgrey] 多任务并行
                    *_ SMP 对称多处理器
                    *_ NUMA 非一致存储访问
                    *_ MPP 海量并行处理结构
            *[#lightgreen] 集群复杂度
                *[#lightgrey] 任务分配
                *[#lightgrey] 任务分解
        *[#lightblue] 复杂度的来源 高可用 冗余
            *[#lightgreen] 计算高可用
                *[#lightgrey] 任务分配器
                    *_ 链接建立/检测/断链处理
                    *_ 双机算法
                        *_ 主备 冷备/温备/热备
                        *_ 主主
            *[#lightgreen] 存储高可用
                *[#lightgrey] 备份数据
                    *_ 备份可能导致不一致
                    *_ 不一致导致复杂处理策略
            *[#lightgreen] 状态决策
                *[#lightgrey] 状态判断异常时采取行动
                    *_ 独裁
                    *_ 协商式
                    *_ 民主式 脑裂
        *[#lightblue] 复杂度的来源 可扩展
            *[#lightgreen] 预测变化
                *_ 不能都考虑/不能不考虑/考虑都可能不对
                *_ 2年法则
            *[#lightgreen] 应对变化
                *[#lightgrey] 分层
                    *_ 变化层/稳定层
                    *_ 抽象层/实现层
                *[#lightgrey] 1写2抄3重构
        *[#lightblue] 复杂度的来源 低成本/安全/规模
            *[#lightgreen] 低成本
                *_ 与高性能/高可用冲突
                *_ 通常不是首要目标/而是附加约束
                *_ 通常需要创新
                    *_ 引入新技术
                        *_ NoSQL解决关系型DB应对高并发
                        *_ 全文搜索引擎(ES/Solr/Sphinx)解决关系型DB like搜索低效
                        *_ Hadoop解决传统文件系统无法应对海量数据
                    *_ 开创全新技术领域
                        *_ LinkedIn开发Kafka
                        *_ Weibo在Redis/MySQL间加入SSD cache
                        *_ Ruby换Java
            *[#lightgreen] 安全
                *[#lightgrey] 功能安全 防小偷
                    *_ XSS/CSRF/SQL注入/Windows漏洞/密码破解
                *[#lightgrey] 架构安全 防强盗
                    *_ 防火墙 隔离网络 控制访问策略
            *[#lightgreen] 规模
                *[#lightgrey] 功能增加导致复杂度指数增长
                *[#lightgrey] 数据增加导致复杂度增长
                    *_ 关系型表太大 拆表 拆分规则+查询处理
        *[#lightblue] 架构三原则
            *[#lightgreen] 合适
                *_ 将军难打无兵之仗
                *_ 罗马不是一天建成的
                *_ 冰面下面才是关键 没有卓越业务场景 却幻想灵光一闪成为天才 常常是失败的原因
            *[#lightgreen] 简单
            *[#lightgreen] 演进 演化优于一步到位
        *[#lightblue] 架构案例
            *[#lightgreen] 淘宝
                *_ 个人网站时期,买个系统
                *_ MySQL换Oracle+NAS
                *_ java 1.0 php->java
                    *_ php线程池死锁 请了sun的人 热切java 后面开发了支付宝
                *_ java 2.0
                    *_ 分库/放弃EJB/引入Spring/加入缓存/加CDN/使用开源JBoss
                *_ java 2.0
                    *_ 去IOE
            *[#lightgreen] 手机QQ
                *[#lightgrey] 十万级
                    *_ 存储服务器 接入服务器
                *[#lightgrey] 百万级
                    *_ 存储集群 接入集群 状态同步服务器 长连接集群
                *[#lightgrey] 千万级
                    *_ 分IDC 同步集群
                *[#lightgrey] 亿万级
                    *_ 存储架构 通信架构
        *[#lightblue] 架构设计流程 识别复杂度
            *_ 高性能/高可用/可扩展的取舍/优先级排序
            *[#lightgrey] 实例 微博使用消息队列
                *_ 是否需要高性能
                    *_ 端上数目->总量->峰值TPS(3倍)->留余量
                *_ 是否需要高可用
                    *_ 分析业务不可用的后果+概率
                *_ 是否需要可扩展
                    *_ 不需要
        *[#lightblue] 架构设计流程 设计备选方案
            *[#lightgrey] 常见错误
                *_ 设计最优秀方案
                *_ 只做一个方案
                    *_ 3-5个方案 防止考虑不周/思虑太过
                    *_ 方案差异明显
                    *_ 不局限于熟悉的技术
                *_ 备选方案过于详细 关注技术选型而非细节
            *[#lightgrey] 实例 微博使用消息队列
                *_ Kafka
                *_ 集群+MySQL
                *_ 集群+自研存储
        *[#lightblue] 架构设计流程 评估选择备选方案
            *[#lightgrey] 矩阵属性罗列
                *_ 性能/可用性/硬件成本/项目投入/复杂度/安全/可扩展
                *_ 数量对比法 相当于等权重
                *_ 加权法
                *_ 优先级法
            *[#lightgrey] 实例 微博使用消息队列
                *_ Kafka
                    *_ 性能 高
                    *_ 复杂度 低
                    *_ 硬件成本 低
                    *_ 可运维性 低 运维团队反馈没有经验
                    *_ 可靠性  高
                    *_ 人力投入 低
                    *_ 性能 高
                    *[#lightyellow] RocketMQ对比Kafka
                        *_ 适用场景 Rocket适合业务 Kafka适合日志处理
                        *_ 性能 Kafka单机TPS 百万 Rocket 10万
                        *_ 实时性 均支持pull长轮询 Rocket实时性更好
                        *_ 定时消息 Kafka不支持 Rocket支持
                        *_ 可靠性  Rocket支持同/异步刷盘 同/异步Replication Kafka异步刷盘 异步Replication
                        *_ 消息顺序 Kafka支持顺序,但是一台Broker宕机后会乱序 Rocket支持严格顺序,一台Broker宕机,发送会失败不会乱序
                        *_ 失败重试 Rocket支持 Kafka不支持
                        *_ 分布式事务消息 Rocket支持 Kafka不支持
                        *_ 消息查询 Rocket支持 Kafka不支持
                        *_ 消息回溯 Rocket支持时间精确到毫秒 Kafka支持offset
                        *_ 支持队列 Rocket单机5w Kafka单机超过64队列/分区,发送性能会降低
                *_ 集群+MySQL
                    *_ 性能 中
                    *_ 复杂度 中
                    *_ 硬件成本 高
                    *_ 可运维性 高
                    *_ 可靠性 高
                    *_ 人力投入 中
                *_ 集群+自研存储
                    *_ 性能 高
                    *_ 复杂度 高
                    *_ 硬件成本 低
                    *_ 可运维性 高
                    *_ 可靠性 低
                    *_ 人力投入 高
        *[#lightblue] 架构设计流程 详细方案设计
            *[#lightgrey] Nginx负载均衡策略
                *_ 轮询
                *_ 加权轮询 适用于新老server性能不一致
                *_ ip_hash 适用于session
                *_ fair 根据server响应时间
                *_ url_hash 适用于server能将url结果缓存
            * 详细设计发现不可行要回溯
                *_ 架构师要熟悉技术细节
                *_ 分步骤/分阶段/分系统 降低方案复杂度
            *[#lightgrey] 实例 微博使用消息队列
                *[#lightyellow] 集群+MySQL
                    *_ 数据表如何设计
                    *_ 数据如何复制 MySQL主从
                    *_ 主备服务器如何切换 ZooKeeper
                    *_ 业务如何写入
                    *_ 业务如何读取
                    *_ 业务和Broker的通信协议 TCP ProtocolBuffer
    *[#pink] 2高性能架构
        *[#lightblue] 读写分离
            *[#lightgrey] 复制延迟
                *_ 写操作后的读操作在master 侵入code
                *_ 读slave后失败读master 引发雪崩
                *_ 关键业务全部读写master
            *[#lightgrey] 分配机制
                *[#lightyellow] 程序封装
                    *_ 实现简单/每个语言一次/故障情况,如果发生主从切换,所有系统都需要修改配置&重启
                    *_ 开源方案 淘宝TDDL Taobao Distributed Data Layer
                *[#lightyellow] 中间件封装
                    *_ 支持多语言
                    *_ 中间件要完整支持SQL语法和协议,实现复杂,易出bug,需要长时间才能稳定
                    *_ 所有操作经过 性能要求高
                    *_ 主从切换不影响业务server
                    *[#lightgreen] 开源方案
                        *_ MySQL Proxy(Official但没有GA)
                            *_ Atlas 奇虎360基于MySQL Proxy实现
                        *_ MySQL Router(Official)
        *[#lightblue] 分库分表
            *[#lightgrey] 分库
                *_ join问题
                *_ 事务问题
                *_ 成本问题
            *[#lightgrey] 分表
                *[#lightgreen] 垂直分表
                    *_ 不常用,但占用大量空间的列拆分出去
                    *_ 表操作数增加
                *[#lightgreen] 水平分表
                    *[#lightgrey] 路由
                        *_ 范围
                            * 优点 随数据增加平滑扩充新的表
                            * 缺点 数据可能分布不均匀
                        *_ Hash
                            * 优点 数据分布均匀
                            * 缺点 随数据增加扩充新的表麻烦 所有数据需要重新分布
                        *_ 配置路由
                            * 优点 设计简单 使用灵活
                            * 缺点 需要多查询一次 路由表也可能是性能瓶颈
                    *_ join 多次查询 再合并
                    *_ count
                        * 相加 简单 但性能低
                        * 记录数 表
                            *_ 性能好
                            *_ 复杂度高
                    *_ order by 只能多次查询 再汇总排序
        *[#lightblue] NoSQL
            *[#lightgreen] 关系型DB的问题
                * 关系型存储行数据 无法支持复杂数据结构
                * schema强约束 扩展不便
                * 大数据场景IO较高 即使只对一列运算 整行数据进入内存
                * 全文搜索功能弱 like整表扫描
            *[#lightgreen] NoSQL的优势 牺牲ACID获得
            *[#lightgreen] KV存储 复杂数据结构 Redis
                * 事务仅支持I/C无法保证A/D
            *[#lightgreen] 文档数据库 解决强schema约束 MongoDB
                *_ 新增字段简单 历史数据不会出错 支持复杂数据结构
                *_ 不支持事务
                *_ 不支持join
            *[#lightgreen] 列式数据库 大数据IO问题 HBase
                *_ 节省IO 操作列不需要读整行数据
                *_ 数据压缩比高 列数据相似度更高
                *_ 频繁更新多个列时 可能有性能问题 因为多个列存储在磁盘不连续空间 随机写效率差
                *_ 因为压缩率高 更新需要解压缩更新再压缩
            *[#lightgreen] 全文搜索引擎 全文搜索能力 ElasticSearch
                *_ 基本原理 inverted index 正排是文档到单词
        *[#lightblue] 缓存架构
            *_ 单机MemCache tps 5万以上
            *[#lightgreen] 缓存穿透
                *_ 数据不存在 放逻辑空值预防
                * 缓存数据生成成本高
                    *_ 识别爬虫禁止访问 可能影响SEO(搜索引擎优化)和推广
                    *_ 监控识别 及时处理
            *[#lightgreen] 缓存雪崩
                *_ 更新锁 只有一个线程能更新缓存, 分布式情况可能需要分布式锁
                *_ 后台更新 缓存预热
            *[#lightgreen] 缓存热点
                *_ 多缓存节点 过期时间范围内随机
        *[#lightblue] 单服务器 PPC&TPC
            *[#lightgreen] 性能关键 并发模型
                *_ 如何处理连接
                *_ 如何处理请求
                *_ IO模型 阻塞与否/同步与否
                *_ 进程模型 单进程/多进程/多线程
            *[#lightgreen] PPC(Process Per Connection)
                * 流程
                    *_ 父进程 socket bind listen accept fork close
                    *_ 子进程 read 业务处理 write close
                * 问题
                    *_ fork代价高
                    *_ 进程通信复杂 IPC(Interprocess Communication)
                    *_ 并发不高 最多几百
                * pre-fork
                    * 优点 省去fork操作
                    * 缺点 惊群(Linux 2.6+解决)
                    * Apache MPM pre-fork 支持256连接
            *[#lightgreen] TPC(Thread Per Connection)
                * 流程
                    *_ 父进程 socket bind listen accept p-thread
                    *_ 子线程 read 业务处理 write close
                * 优点 解决 fork代价高/进程间通信复杂
                * 缺点 创建线程也有代价/线程间共享&互斥复杂/多线程互相影响(单线程可能导致进程退出)
                * pre-thread
                    * Apache MPM worker 默认支持16*25=400并发线程
        *[#lightblue] 单服务器 Reactor&Proactor
            * IO说明
                *_ IO两步1将数据读到内核空间2将数据读到用户空间
                *_ 一般来说,1的耗时远大于2
                *_ 1和2都阻塞是同步阻塞IO
                *_ 1非阻塞2阻塞是同步非阻塞IO(Reactor)
                *_ 1非阻塞2非阻塞是异步非阻塞IO(Proactor)
            *[#lightgreen] Reactor(Dispatcher)
                *_ PPC的问题 每个连接创建/销毁进程,开销大 解决方式:资源池
                * 后续问题 阻塞IO效率低 可以改为非阻塞+轮询
                    *_ CPU开销大
                    *_ 连接数多的时候轮询效率低
                * IO多路复用
                    * 多连接共用一个阻塞对象后,进程只在一个阻塞对象等待,不再轮询所有连接
                        *_ 常见实现方式 select/epoll/kqueue
                    *_ 当某条连接有数据可以处理时,操作系统通知进程,进程从阻塞态返回,进行业务处理
                * Reactor典型方案
                    *[#lightyellow] 单reactor 单进程/线程
                        * 方案
                            *_ Reactor对象通过select监控连接事件,收到事件后通过dispatch进行分发
                            *_ 如果是连接建立的事件,则由Acceptor处理,Acceptor通过accept接受连接,并创建一个Handler来处理连接后续的各种事件
                            *_ 如果不是连接建立事件,则Reactor会调用连接对应的Handler(第2步中创建的Handler)来进行响应
                            *_ Handler会完成read->业务处理->send的完整业务流程
                        * 特点
                            *_ 优点 简单,无进程间通信,无进程竞争
                            *_ 缺点 只有一个进程,无法发挥CPU多核性能
                            *_ 缺点 Handler在处理某个连接上的业务时,无法处理其他连接的事件,很容易导致性能瓶颈
                        * 适用场景 业务处理非常快速Redis/C语言一般是单进程/Java一般是单线程,因为JVM才是进程
                    *[#lightyellow] 单reactor 多线程
                        * 方案
                            *_ 主线程中,Reactor对象通过select监控连接事件,收到事件后通过dispatch进行分发
                            *_ 如果是连接建立的事件,则由Acceptor处理,Acceptor通过accept接受连接,并创建一个Handler来处理连接后续的各种事件
                            *_ 如果不是连接建立事件,则Reactor会调用连接对应的Handler(第2步中创建的Handler)来进行响应
                            *_ Handler只负责响应事件,不进行业务处理;Handler通过read读取到数据后,会发给Processor进行业务处理
                            *_ Processor会在独立的子线程中完成真正的业务处理,然后将响应结果发给主进程的Handler处理;Handler收到响应后通过send将响应结果返回给client
                        * 特点
                            *_ 优点 可以充分利用多核处理能力
                            * 缺点 多线程数据共享/访问复杂
                                *_ 子线程处理后将结果返回主线程,涉及共享数据的互斥/保护机制
                                *_ 以Java的NIO为例 Selector线程安全\n但Selector.selectKeys返回的集合非线程安全\n对selectedKeys必须单进程处理或采取同步措施保护
                            *_ 缺点 Reactor承担所有event的监听/响应,只在主线程运行,瞬间高并发会成为性能瓶颈
                            *_ 之所以没有单Reactor多进程,是因为进程间通信比线程更复杂
                    *[#lightyellow] 多reactor 多进程/线程
                        * 方案
                            *_ 父进程中mainReactor对象通过select监控连接建立事件,收到事件后通过Acceptor接收,将新的连接分配给某个子进程
                            *_ 子进程的subReactor将mainReactor分配的连接加入连接队列进行监听,并创建一个Handler用于处理连接的各种事件。
                            *_ 当有新的事件发生时，subReactor会调用连接对应的Handler(即第2步中创建的Handler)来进行响应
                            *_ Handler完成read→业务处理→send的完整业务流程
                        * 特点 相对单Reactor多线程更简单
                            *_ 父进程和子进程的职责非常明确,父进程只负责接收新连接,子进程负责完成后续的业务处理
                            *_ 父进程和子进程的交互很简单,父进程只需要把新连接传给子进程,子进程无须返回数据
                            *_ 子进程之间是互相独立的,无须同步共享之类的处理(这里仅限于网络模型相关的select、read、send等无须同步共享,“业务处理”还是有可能需要同步共享的)
                        * 开源实现
                            *_ 多Reactor多进程 Nginx
                            *_ 多Reactor多线程 MemCache/Netty
            *[#lightgreen] Proactor
                *_ Reactor非阻塞同步网络模型:read/send都是同步,Proactor是异步网络模型
                * 方案
                    *_ ProactorInitiator负责创建Proactor和Handler,并将Proactor和Handler都通过AsynchronousOperationProcessor注册到内核
                    *_ AsynchronousOperationProcessor负责处理注册请求,并完成I/O操作
                    *_ AsynchronousOperationProcessor完成I/O操作后通知Proactor
                    *_ Proactor根据不同的事件类型回调不同的Handler进行业务处理
                    *_ Handler完成业务处理,Handler也可以注册新的Handler到内核进程
        *[#lightblue] 负载均衡 分类及架构
            *_ 负载均衡不只是为了业务单元的负载达到均衡状态/本质是业务分配器
            *[#lightgreen] DNS负载均衡 地理级别
                *_ 简单/成本低/就近访问 提升速度
                *_ 更新不及时/扩展性差/分配策略简单
            *[#lightgreen] 硬件负载均衡 F5/A10 集群级别
                *_ 功能&性能强(百万级)/稳定性好/支持安全防护
                *_ 价格高/扩展能力差
            *[#lightgreen] 软件负载均衡 机器级别
                *_ Nginx&LVS
                    *_ Nginx软件7层
                    *_ Linux内核4层
                    *_ 协议和灵活性 Nginx支持http/Email协议 LVS协议无关,都可以做,例如聊天/数据库
                *_ 简单/便宜/灵活
                *_ 性能一般(Nginx5w,LVS10w级)/功能没有硬件强/一般不具备安全功能(防火墙和防DDos攻击等)
        *[#lightblue] 负载均衡算法
            *_ 任务平分类/负载均衡类/性能最优/Hash类
            *_ 轮询 简单/不关心服务器状态
            *_ 加权轮询 解决机器能力不一致
            *_ 负载最低优先 感知机器状态/复杂
            *[#lightgreen] 性能最优类
                *_ 全部统计响应时间 本身也消耗性能
                *_ 部分统计 确定合适采样率 本身复杂
                *_ 统计周期如何确认 比较复杂
            *_ 任务平分类/负载均衡类/性能最优/Hash类
            *[#lightgreen] Hash类
                *_ 源地址
                *_ 业务ID
    *[#pink] 3高可用架构
        *[#lightblue] CAP理论
            *_ 分布式系统(inter-connected & share-data)在读写操作时,无法CAP三项全选
            *_ C consistency 一致性 对指定客户端来说,读操作保证返回最新写操作结果
            *_ A availability 可用性 非故障节点在合理时间返回合理响应
            *_ P partition tolerance 分区容忍性 网络分区后系统可以继续function
            *_ 逻辑上CA不可选 只能CP or AP
        *[#lightblue] CAP细节
            *[#lightgreen] CAP细节
                *_ CAP关注的是data not system
                *_ CAP是忽略网络延迟的
                *_ 既要考虑分区时CP or AP, 更要考虑不分区时尽量CA
                *_ 为分区恢复做准备
            *_ ACID
            *[#lightgreen] BASE
                *_ Basically Available 损失部分 保证核心
                *_ Soft State 即不一致
                *_ Eventually Consistency
        *[#lightblue] FMEA方法 排除可用性隐患
            *[#lightgreen] 介绍
                *_ Failure mode and effects analysis
                *_ 给出初始架构设计图
                *_ 假设某个部件出故障
                *_ 分析影响
                *_ 根据分析做优化
            *_ 功能点 用户视角而非系统各个模块功能划分
            *_ 故障模式 故障点/故障形式 只关注现象,暂不关注原因 多量化描述
            *_ 故障影响 偶尔不可用/完全不可用/部分用户不可用/响应慢/结果出错 多量化描述
            *[#lightgreen] 严重程度 致命/高/中/低/无 五档
                *_ 严重程度 = 功能点重要程度*故障影响范围*功能点受损程度
            *[#lightgreen] 原因
                *_ 概率不同
                *_ 检测手段不同
                *_ 处理措施不同
            *[#lightgreen] 概率 高/中/低
                *_ 硬件
                *_ 开源系统
                *_ 自研系统
            *_ 风险程度 严重程度*概率
            *_ 已有措施 告警/容错/自恢复
            *_ 规避措施 技术手段/管理手段
            *_ 解决措施
            *_ 后续规划
            *_ FMEA实战
        *[#lightblue] 高可用存储 双机架构
            *_ 数据如何复制/节点职责/应对复制延迟/应对复制中断
            *[#lightgreen] 主备复制
                *_ 简单 只需复制数据 无需判断状态
                *_ 备机仅备份,浪费资源 故障需要人工干预
            *[#lightgreen] 主从复制
                *_ 主机故障,不影响读 发挥了硬件性能
                *_ 复杂 延迟可能导致不一致 故障需要人工干预
            *[#lightgreen] 双机切换
                *_ 主备状态判断
                    *_ 状态传递渠道
                    *_ 状态检测内容
                *_ 切换决策 时机/策略/自动程度
                *_ 数据冲突解决
                *_ 互连式 自动决定主机 依赖状态传递渠道
                *_ 中介式 状态决策更简单 中介高可用 MongoDB ReplicaSet
                *_ 模拟式 实现简单 状态信息少,决策可能有偏差
            *_ 主主复制 无需状态信息传递/状态决策/状态切换 但数据要双向复制 适用于临时性/可丢失/可覆盖
        *[#lightblue] 高可用存储 集群和分区
            *[#lightgreen] 数据集群
                *[#lightgrey] 数据集中
                    *_ 如何复制给备机 多通道:主机压力大/数据一致性难保证
                    *_ 如何检查主机状态
                    *_ 如何决定新的主机
                *[#lightgrey] 数据分散
                    *_ 均衡性
                    *_ 容错性
                    *_ 可伸缩性
                    *_ 执行数据分配角色
                        *_ Hadoop nameNode
                        *_ ElasticSearch masterNode
            *[#lightgreen] 数据分区
                *[#lightgrey] 考量
                    *_ 数据量 直接决定分区规则的复杂度
                    *_ 分区规则 地理级别 业务范围/成本
                    * 复制规则
                        *_ 集中式 设计简单/容易扩展/成本高
                        *_ 互备式 设计复杂/扩展麻烦/成本低
                        *_ 独立式 设计简单,互不影响/扩展容易/成本高
        *[#lightblue] 如何设计计算高可用
            *[#lightgreen] 复杂度主要体现在任务管理方面
                *_ 哪些服务器可以执行任务
                *_ 任务如何重新执行
                *_ 需要逻辑上的任务分配角色
            *[#lightgreen] 主备 简单
                *_ 冷备 节省能源 切换时间长
                *_ 温备 服务已经启动,但不对外暴露
            *[#lightgreen] 主从
                *_ 从机也执行 发挥硬件性能
                *_ 任务分类,更复杂
            *[#lightgreen] 集群
                *_ 主备/主从 需要人工切换 集群自动完成切换
                *[#lightgrey] 对称集群 所有server角色一样
                    *_ 即负载均衡
                    *_ 需要分配策略
                    *_ 需要检测server状态
                *[#lightgrey] 非对称集群
                    *_ 任务分配更复杂
                    *_ 角色分配实现更复杂
        *[#lightblue] 业务高可用 异地多活
            *_ 复杂度高 成本高
            *[#lightgreen] 同城异区
                *_ 延迟低
                *_ 防机房级别故障
            *[#lightgreen] 跨城异地
                *_ 防极端灾难
                *_ 信号在光纤差不多20wkm/s
                *_ 北京到广州RTT(Round Trip Time) 50ms
                *_ 数据一定会不一致
            *[#lightgreen] 跨国异地
                *_ 服务不同区
                *_ 只读业务
        *[#lightblue] 异地多活 4大技巧
            *[#lightgreen] 保证核心业务的异地多活
                *_ 以账号系统为例,登录是核心功能,注册和用户信息不是
            *[#lightgreen] 保证核心数据的最终一致
                *_ 加快同步速度,例如搭建高速网络 cost高
                *_ 只同步核心数据
                *_ 只保证最终一致
            *[#lightgreen] 采用多种手段同步数据
                *_ 消息队列
                *_ 二次读取
                *_ 存储系统同步方式
                *_ 回源读取
                *_ 重新生成数据
            *[#lightgreen] 只保证绝大多数用户的异地多活
                *_ trade off有的点只能sacrifice
                *_ 挂公告
                *_ 事后补偿
                *_ 补充体验
        *[#lightblue] 异地多活设计4步走
            *[#lightgreen] 业务分级
                *_ 访问量大 核心业务 产生大量收入
            *[#lightgreen] 数据分类
                *_ 数据量
                *_ 唯一性
                *_ 实时性
                *_ 可丢失性
                *_ 可恢复性
            *[#lightgreen] 数据同步
                *_ 消息队列
                *_ 重复生成
                *_ 存储系统同步
            *[#lightgreen] 异常处理
                * 目的
                    *_ 问题发生时,避免少量数据异常导致整体业务不可用
                    *_ 问题恢复后,修正异常数据
                    *_ 安抚用户,弥补用户损失
                * 多通道同步
                    *_ 一般双通道即可
                    *_ 不能用相同的网络连接
                    *_ 数据可覆盖
                * 同步和访问结合
                    *_ 数据有路由规则
                    *_ 不能用相同的网络连接
                    *_ 数据优先本地 适合实时性要求高的数据
                * 日志记录 用于数据恢复
                    *_ 服务器上,数据库中保存日志
                    *_ 本地独立系统保存日志
                    *_ 日志异地保存
                *_ 用户补偿 给代金券/红包
        *[#lightblue] 如何应对接口级故障
            *_ 主要原因系统压力大,负载太高,无法快速处理,引发更多后续问题
                *_ 内部原因 bug/数据库慢查询/逻辑不完善导致内存耗尽
                *_ 外部原因 黑客/促销or抢购/三方系统请求量大/三方系统响应慢
            *[#lightgreen] 降级 丢卒保车
                *_ 系统后门降级 成本低 需要一台台操作服务器
                *_ 独立降级系统 降级到单独系统
            *[#lightgreen] 熔断
                *_ 降级处理内部系统故障 熔断处理外部系统故障
                *_ 需要统一API调用层
                *_ 阈值设计
            *[#lightgreen] 限流
                *[#lightgrey] 基于请求
                    *_ 限制总量
                    *_ 限制时间量
                    *_ 难点在合理阈值 适用于业务功能相对简单的系统
                *[#lightgrey] 基于资源
                    *_ CPU占有率/队列长度
                    *_ 难点在如何确定关键资源,如何设定合理阈值
                *[#lightgrey] 限流算法
                    *[#lightyellow] 时间窗
                        *_ 固定时间窗 简单 但存在临界点问题
                        *_ 滑动时间窗 效果更好 实现更复杂
                    *[#lightyellow] 桶
                        *_ 漏桶
                            *_  流入速率不固定/匀速流出/桶满丢弃
                            *_  总量控制 桶大小是关键
                            *_  突发流量丢弃少 桶能缓存请求
                            *_  桶大小不易动态调整
                            *_  无法控制流出速度
                            *_  适用于瞬时高并发(秒杀)
                        *_ 令牌桶
                            *_  固定速度放入桶内令牌/业务请求先拿牌/拿不到牌丢弃
                            *_  速率控制
                            *_  突发流量丢弃相对多,因为桶内不能累积太多令牌
                            *_  速率可动态调整
                            *_  实现相对复杂
                            *_  适用于控制访问第三方/控制自己处理速度
            *[#lightgreen] 排队
                *_ 实际是限流的变种
                *_ 12306 排队/调度/服务模块
left side
    *[#pink] 4可扩展架构
        *[#lightblue] 可扩展架构的基本思想和模式
            *_ 基本思想:拆分,控制规模/影响范围
            *[#lightgreen] 拆分模式
                *_ 面向流程/服务/功能
                *_ 流程>服务>功能
                *_ 以网络模型为例,N层是流程;HTTP/FTP/SMTP是服务;GET/POST;上传/下载;邮件收发是功能
                *_ 流程:展示层->业务层->数据层->存储层
                *_ 服务:注册/登录/信息管理/安全设置
                *_ 功能:注册:手机号&邮箱/登录:手机号&邮箱/信息管理:基本&成绩&课程信息/安全设置:修改&重置密码
            *[#lightgreen] 可扩展方式
                *_ 流程:分层架构
                *_ 服务:SOA 微服务
                *_ 功能:微内核架构
        *[#lightblue] 传统可扩展架构模式:分层架构和SOA
            *[#lightgreen] 分层
                *[#lightgrey] 常见分层架构
                    *_ C/S B/S
                    *_ MVC MVP
                    *_ 逻辑分层
                *_ 各层差异清晰 边界明显
                *_ separation of concerns
                *_ 分层内只处理本层逻辑 分层间依赖稳固
                *_ 层层传递 不能跳层
                *_ 优势:降低了复杂度 劣势:冗余和性能
            *[#lightgreen] SOA (Service Oriented Architecture)
                *_ 服务/ESB(Enterprise Service Bus)/松耦合
                *_ 解决了传统IT系统重复建设和扩展效率低的问题 但引入更多复杂性
                *_ ESB可能需要转换各种协议 本身可能成为性能瓶颈 本质是需要适配异质系统
        *[#lightblue] 深入理解微服务架构:银弹or焦油坑
            *[#lightgreen] 与SOA的关系
                * 常见观点
                    *_ 微服务是SOA的实现方式 粒度更细
                    *_ 微服务是无ESB的SOA
                * 差异
                    *_ 粒度 微服务更小
                    *_ 通信 微服务无ESB
                    *_ 服务交付 微服务快速交付 但对自动化测试,CI/CD要求更高
                    *_ 适用场景
                        *_ SOA:庞大/复杂/异质的企业系统
                        *_ 微服务:快速轻量基于web的互联网系统
                *_ keyword:small lightweight automated
            *[#lightgreen] 微服务陷阱
                *_ 粒度过细 关系复杂
                *_ 服务数量太多 团队效率下降
                *_ 调用链太长 性能下降
                *_ 调用链太长 问题定位困难
                *_ 若无自动化支撑 无法快速交付
                * 若无服务治理 多了之后管理混乱
                    *_ 服务路由 其他业务依赖如何知道部署情况
                    *_ 服务故障隔离 一半节点故障,如何处理
                    *_ 服务注册发现 扩容一倍,其他业务依赖如何获悉
        *[#lightblue] 微服务最佳实践:方法篇
            *[#lightgreen] 服务粒度\n建议以团队规模拆分 一个微服务3个人
                *_ 复杂度不高不低
                *_ 可以形成稳定备份
                *_ 可以形成有效讨论
            *[#lightgreen] 拆分方法
                *_ 基于业务逻辑 业务职责划分 直观
                *_ 基于可扩展 基于稳定性排序 划分稳定服务和变动服务
                * 基于可靠性 按照优先级排序 划分可靠性要求高的核心服务/低的非核心服务
                    *_ 避免非核心服务影响核心服务
                    *_ 核心高可用更简单
                    *_ 降低高可用成本
                * 基于性能 分析瓶颈
            *[#lightgreen] 基础设施
                *_ 服务发现/路由/容错/监控/跟踪/安全/\n自动化测试/自动化部署/配置中心/接口框架/API网关
                * 优先级
                    *_ 1服务发现/路由/容错 最基础
                    *_ 2接口框架/API网关 接口框架提升内部开发效率/API网关提升与外部服务对接效率
                    *_ 3自动化测试/自动化部署/配置中心 提升测试运维效率
                    *_ 4服务监控/跟踪/安全 进一步提升运维效率
                    *_ 节点越多,3和4越重要,节点较少时,可人工支撑
        *[#lightblue] 微服务最佳实践:基础设施篇
            *[#lightgreen] 自动化测试
                *_ code级别单元测试
                *_ 系统级集成测试
                *_ 系统间接口测试
            *[#lightgreen] 自动化部署
                *_ 版本管理
                *_ 资源(机器/虚拟机)管理
                *_ 部署操作
                *_ 回退操作
            *[#lightgreen] 配置中心
                *_ 版本管理
                *_ 修改
                *_ 节点管理
                *_ 配置同步
                *_ 配置推送
            *_ 接口框架 RESTFUL/RPC
            *[#lightgreen] API网关
                *_ 接入鉴权 Authentication
                *_ 权限控制 Authorization
                *_ 传输加密
                *_ 请求路由
                *_ 流量控制
            *[#lightgreen] 服务发现
                *_ 自理式 微服务自己完成服务发现
                *_ 代理式 微服务调用有负载均衡系统 实现简单,但有可用性/性能风险
                *_ 核心是服务注册表 记录节点配置和状态,节点启动时注册到服务注册表
            *[#lightgreen] 服务路由
                *_ 随机/轮询/最小压力/最小连接数路由
            *[#lightgreen] 服务容错
                *_ 请求重试/流控/服务隔离
                *_ 通常集成在服务发现/路由系统中
            *[#lightgreen] 服务监控
                *_ 实时搜集信息并分析,减少了处理时间
                *_ 在分析结果上预警,降低问题影响范围和时间
                *_ 因为需要搜集/分析大量数据,通常独立系统,不推荐集成在服务发现/API网关系统中
            *[#lightgreen] 服务跟踪
                *_ 监控(宏观)关注 记录请求次数/响应时间平均值/响应时间最高值/错误码分布
                *_ 跟踪(微观)关注 某次请求的发起/响应时间,错误码,输入,输出,串联信息
            *[#lightgreen] 服务安全
                *_ 接入/数据/传输安全
                *_ 安全策略可以配置在配置中心
        *[#lightblue] 微内核架构详
            *[#lightgreen] 简介
                *_ MicroKernel又称Plug-in 通常基于product-based(多个版本,需要下载使用,对应web-based)
            *[#lightgreen] 基本架构
                *_ Core System(模块加载和模块通信)/plug-in modules(业务逻辑)
                *_ Core System功能稳定
                * 设计关键点
                    *_ 插件管理 插件注册表
                    *_ 插件连接 插件和核心的连接规范
                    *_ 插件通信 类比计算机的主板总线
            *[#lightgreen] OSGi Open Services Gateway initiative
                *_ Module层 Bundle MANIFEST.MF
                *_ LifeCycle层 定义Bundle的生命周期操作
                *_ Service层 提供服务注册,此处实际上是插件间通信机制
            *[#lightgreen] 规则引擎
                *_ 可扩展/易理解/高效率
                *_ 常见的是Drools Java编写 基于Rete算法
                *_ 社区活跃/执行快速/与Java Rule Engine API(JSR-94)兼容
                *_ 提供基于Web的BRMS(Business Rule Management System) Guvnor 提供规则管理知识库,可以实现规则版本控制/在线修改&编译
    *[#pink] 5架构实战
        *[#lightblue] 如何判断技术演进方向
            *_ 潮流派/保守派/跟风派
            *_ 潮流派 容易白鼠&资源浪费/保守派 落后/跟风派 没风可跟&邯郸学步
            *_ 演进动力:业务发展 市场/技术/管理 都是支持业务
            *_ 业务分两类 产品类(如iPhone)/服务类(如微信)
            *_ 产品类 技术创新推动业务发展 主推"功能"
            *_ 服务类 业务发展推动技术发展 主推"规模"
            *_ "规模"成为决定因素后 服务模式创新成为业务发展的核心驱动力
            *_ 技术演进的模式就是对业务发展阶段做判断
        *[#lightblue] 技术演进模式
            *_ 不同时期差异主要在 复杂性/用户规模
            *_ 初创期 业务:创新 技术:快
            *[#lightgreen] 发展期
                *_ 堆功能期
                *_ 优化期 好处是快 确定是可能过不了多久又撑不住
                *_ 架构期 主要是拆 好处是可以撑很久 缺点是动作大,耗时长,对业务影响大
            *[#lightgreen] 竞争期
                *_ 重复造轮子/交互一团麻
                * 平台化:解决重复造轮子
                    *_ 存储平台化 淘宝TFS/京东JFS
                    *_ 数据库平台化 淘宝TDDL/百度DBproxy
                    *_ 缓存平台化 Twitter Twemproxy/豆瓣 BeansDB/腾讯 TTC
                * 服务化:解决系统交互问题
                    *_ 消息队列 阿里RocketMQ/LinkedIn Kafka
                    *_ 服务框架 Facebook thrift/淘宝Dubbo
            *_ 成熟期 细节求精优化 无固定套路
            *_ 用户规模 性能/可用性 量变到质变
            *_ timing 问题将发而未发
        *[#lightblue] 存储层技术
            *[#lightgreen] 框架
                *_ 业务层 网购/IM/搜索
                *_ 用户层 用户管理/消息推送/存储云/图片云
                *_ 网络层 负载均衡/CDN/多机房/多中心
                *_ 服务层 配置中心/服务中心/消息队列
                *_ 开发层 开发框架/服务器/容器
                *_ 存储层 SQL/NoSQL/小文件/大文件
                *_ 测试/运维/数据/管理平台
            *[#lightgreen] SQL
                * 中间件
                    *_ 百度DBproxy/淘宝TDDL
                    *_ 开源方案:MySQL Router/360Atlas
                *_ 大公司SQL平台:如OceanBase
            *[#lightgreen] NoSQL
                * 大公司平台
                    *_ 资源动态分配
                    *_ 资源自动管理
                    *_ 故障自动处理
            *[#lightgreen] 小文件
                *_ 不一定需要规模很大,公司起步就可以做
                *_ 开源方案封装 Hbase/Hadoop/HyperTable/FastDFS
                *_ 淘宝TFS/京东JFS/FaceBook Haystack
            *[#lightgreen] 大文件
                *_ Google BigTable/MapReduce/GFS
                *_ Yahoo开源Hadoop/HDFS/HBase/Hive/Storm
                *_ 大公司基于开源封装:淘宝云梯系统/腾讯TDW
        *[#lightblue] 开发层/服务层技术
            *[#lightgreen] 开发层
                * 框架 优选成熟的框架,避免盲目追随新技术
                    *_ 文档齐备,坑都被人踩过了,有问题搜索解决
                    *_ 受众广,招人方便
                    *_ 稳定,变动不大,适合长期发展
                *_ 服务器 开源方案 二次开发(如淘宝Tengine)
                *_ 容器 Docker
            *[#lightgreen] 服务层
                * 配置中心
                    *_ 优点
                        *_ 集中配置多个系统，操作效率高。
                        *_ 所有配置都在一个集中的地方，检查方便，协作效率高
                        *_ 配置中心可以实现程序化的规则检查，避免常见的错误
                        *_ 配置中心相当于备份了系统的配置，当某些情况下需要搭建新的环境时，能够快速搭建环境和恢复业务。
                    *_ 识别key:系统标识+host+port
                * 服务中心
                    *_ Service Name System 类似DNS
                    *_ Service Bus System
                *_ 消息队列 解耦;若对可靠性/时序/事务有要求,开源方案容易踩坑
        *[#lightblue] 网络层技术
            *_ 负载均衡
                * DNS
                    *_ 通用/成本低
                    *_ 缓存时间长/不够灵活
                * HTTP-DNS
                    *_ 灵活/可控/及时
                    *_ 开发成本高/侵入性:App端要做改造
                *_ Nginx/LVS/F5
            *_ CDN 解决最后一公里/空间换时间/基础服务 直接购买/对大多数程序员透明
            *_ 多机房
            *_ 多中心
        *[#lightblue] 用户层/业务层技术
            *[#lightgreen] 用户层
                * 用户管理
                    *_ 单点登录Single Sign On(SSO)
                        *_ 成熟开源实现方案 Central Authentication Service(CAS)
                    *_ 授权登录OAuth 2.0
                * 消息推送
                    *_ 核心三点:设备管理/连接管理/消息管理
                    *[#lightyellow] 难点
                        *_ 海量设备/用户管理
                        *_ 推送设备多,管理复杂
                        *_ 连接保活
                        *_ 消息管理
                        *_ 推送规则维护
                *_ 存储云/图片云 数据量大/体积小/访问有时效性
            *[#lightgreen] 业务层
                *_ 业务拆分
                *_ 分久必合 职责关联性强的合并为虚拟业务域
                *_ 总体思路:高内聚 低耦合
        *[#lightblue] 平台技术
            *[#lightgreen] 运维平台
                *_ 配置(资源管理:机器&IP&虚拟机)
                *_ 部署(包管理/灰度发布/回滚)
                *_ 监控
                *_ 应急(停止程序&下线故障机器&切换IP)
                *_ 标准化/平台化/自动化/可视化
            *[#lightgreen] 测试平台
                *_ 用例管理
                *_ 资源管理
                *_ 任务管理
                *_ 数据管理(执行时间/结果/执行期间资源占用情况等)
            *[#lightgreen] 数据平台
                * 数据管理
                    *_ 数据采集
                    *_ 数据存储
                    *_ 数据访问 对外提供协议用于读写
                    *_ 数据安全
                *_ 数据分析
                    *_ 数据统计
                    *_ 数据挖掘
                    *_ 机器学习
                    *_ 深度学习
                *_ 数据应用 在线应用:推荐/广告 离线应用:报表/欺诈检测/异常检测
            *[#lightgreen] 管理平台 权限管理
                *_ 身份认证
                *_ 权限控制
        *[#lightblue] 有的放矢
            *[#lightgreen] 重构的难点
                *_ 业务不能停
                *_ 关联方多,牵一发动全身
                *_ 旧架构/业务数据的约束
            *[#lightgreen] 识别真正需要通过重构解决的问题,集中力量快速解决
                * 例子
                    *_ 解决不合理的耦合
                    *_ 解决全局单点的可用性问题
                    *_ 解决大系统带来的开发效率问题
                *_ 假设重新干,方案相似选择优化,否则考虑重构
        *[#lightblue] 合纵连横
            *[#lightgreen] 合纵
                *_ 重构是大动作,需要与利益相关方提前沟通好,达成共识
                *_ 将技术语言转换为通用语言,事实说话,数据说话
            *[#lightgreen] 连横
                *_ 重构可能需要相关系统配合
                *_ 阻力:对我有什么好处/我又不急
                *_ 换位思考/合作共赢/关注长期
                *_ 如果对对方不利,与虎谋皮不可取,escalate
                *_ 对方暂时无法配合,约定好排期时间
            *_ plan&dependency analysis&acknowledgement&risk management
        *[#lightblue] 运筹帷幄
            *[#lightgreen] 方法论
                *_ 根据优先级排序
                *_ 分类问题
                *_ 先易后难
                *_ 循序渐进 最少一个月,不超过3个月
            *[#lightgreen] 分段实施
                *_ 根据优先级/重要性/难易度划分不同阶段
                *_ 每阶段聚焦一个整体目标
                *_ 集中精力/资源解决一类问题
                * 好处
                    *_ 目标明确,效果明显,后续更容易推动
                    *_ 工作量不大,可与业务并行
                    *_ 改动不大,降低总体风险
            *[#lightgreen] 分阶段的例子
                *_ 救火
                *_ 组件化
                *_ 解耦
        *[#lightblue] 开源项目选择/使用/二次开发
            *[#lightgreen] 选
                *_ 聚焦是否满足业务
                *_ 聚焦是否成熟 版本号/使用公司数量/社区活跃度
                * 聚焦运维能力
                    *_ 日志齐全
                    *_ 是否有命令行/管理控制台等维护工具,能够看到系统运行时情况
                    *_ 是否有故障检测和恢复能力,例如告警/切换等
                    *_ 如果是开源库,例如Netty,本身不具备运维能力.使用时打印关键信息日志
            *[#lightgreen] 用
                * 深入研究,仔细测试
                    *_ 通读设计文档,了解设计原理
                    *_ 核对配置项作用和影响,识别关键配置项
                    *_ 多场景性能测试
                    *_ 压力测试 连跑几天,观察CPU/内存/磁盘IO等指标的波动
                    *_ 故障测试 kill/断电/拔网线/重启100次/切换等
                *_ 小心应用 灰度发布 非核心业务先用
                *_ 做好应急 以防万一
            *[#lightgreen] 改
                * 保持纯洁 加以包装
                    *_ 不要改原系统 开发辅助系统,例如监控/报警/负载均衡/管理等
                    *_ 以Redis为例,如果想增加集群功能,增加一个proxy层来实现
                    *_ Twitter的Twenproxy就是这样做的,Redis3.0后支持了集群方案,这时可以直接切换
                *_ 发明你要的轮子
        *[#lightblue] App架构演进
            *_ Web App 简单/快速
            *_ 原生App 体验好
            *_ HybridApp 解决iOS/Android/WindowsPhone开发重复
            * 组件化/容器化
                *_ 大App拆分多个组件,各组件独立开发/测试/上线
                *_ 组件:静态发布,统一到App某个版本
                *_ 容器:动态发布,动态加载组件,组件ready直接发布
            * 跨平台App Google Flutter等
        *[#lightblue] 架构设计文档template
            *[#lightgreen] 备选方案模版
                *_ 需求介绍 背景/问题(性能&耦合&效率等)/目标/影响范围等
                * 需求分析
                    *_ 5W2H Who/When/What/Why/Where/How/How Much
                    *_ 8C(Constraints) 性能/成本/时间/可靠性/安全性/合规性/技术性/兼容性
                * 复杂度分析
                    *_ 高可用
                    *_ 高性能
                    *_ 可扩展
                *_ 备选方案list
                *_ 备选方案评估
            *[#lightgreen] 架构设计模版
                *_ 总体方案 模块划分/职责描述/核心feature
                *_ 架构总览 架构图和描述
                *_ 核心流程
                *_ 详细设计
                    *_ 高可用
                    *_ 高性能
                    *_ 可扩展
                    *_ 安全 身份识别/权限控制
                    *_ 其他 开发语言,公司标准等
                *_ 部署方案 硬件要求/部署方式/组网方式
                *_ 架构演进规划 分阶段
        *[#lightblue] 如何画出优秀的软件系统架构图
            *[#lightgreen] 传统4+1视图
                *_ Logical View 终端用户视角 系统提供的功能 class/state
                *_ Process View 动态角度看系统处理过程 sequence/activity
                *_ Development View 程序员角度看系统逻辑组成 package
                *_ Physical View 系统工程师角度看物理组成 deployment
                *_ Scenarios View 用户角度看系统需要实现的需求 use case
            *[#lightgreen] 4R
                *_ rank 先明确级别,只展示该级别的架构信息
                *_ role 画出角色
                *_ relation role之间连线
                *_ rule 挑选核心case,画系统序列图
                *_ role+relation静态架构图 rule动态架构图
                *_ 静态架构图与复杂度有关 一般1-2张
                *_ 动态架构图 多张 因为核心场景一般不只一个
            *[#lightgreen] 系统
                *_ 按业务划分 业务架构
                * 按领域划分 领域架构
                    *[#lightyellow] 客户端
                        *_ 按模块划分 客户端架构
                    *[#lightyellow] 后端
                        *_ 按模块划分 系统/后端架构
                        *_ 按应用划分 应用架构
                        *_ 按组件划分 部署架构
                    *[#lightyellow] 前端
                        *_ 按模块划分 前端架构
            * 具体说明
                *[#lightgreen] 业务架构图
                    *_ 类似4+1的场景视图
                    *_ 不同颜色标识业务状态(颜色最好不超过3个)
                    *_ 分组管理
                    *_ 区块对齐
                *[#lightgreen] 客户端/前端架构图
                    *_ 逻辑架构
                    *_ 用连线表示关系,不同关系用不同形状的线
                    *_ 分层/分组管理
                *[#lightgreen] 系统架构图
                    *_ 逻辑架构
                    *_ 逻辑分组
                *[#lightgreen] 应用架构图
                    *_ 复杂系统分域
                *[#lightgreen] 部署架构图
                    *_ 用图标代替区块(美观)
                *[#lightgreen] 系统序列图
                    *_ 用UML序列图
            *[#lightgreen] 补充说明
                *_ TOGAF(The Open Group Architecture Framework)
                    *_ 业务架构
                    *_ 数据架构(数据资产架构)
                    *_ 应用架构
                    *_ 技术架构
                    *_ 企业级架构 CTO级别
                * C4架构
                    *_ context
                    *_ container
                    *_ component
                    *_ code
    *[#pink] 6特别放送
        *[#lightblue] Q&A1
            *[#lightgreen] 提升技术
                *_ 首先不能着急,循序渐进,持之以恒
                *_ 知行合一
                *_ 多交流
        *[#lightblue] Q&A2
            *[#lightgreen] 原版本架构设计原则
                *_ 合适优于业内领先
                *_ 演化优于过度设计
                *_ 简单优于复杂
                *_ 重构优于重写
                *_ 硬件优于人工
                *_ 专注优于全面
                *_ 开放优于封闭
                *_ 能用优于完美
                *_ 重用优于自研
                *_ 业务优先技术
                *_ 存储优于运算
                *_ 技术优于流程 不要寄希望于提升人的能力/加大测试投入来保证质量
                *_ 分布优于集中
                *_ 优化优于重构
        *[#lightblue] 如何高效学习开源项目
            *_ 不是开发者依然可以学到东西
            *_ 不要盯着数据结构和算法
            *[#lightgreen] 自顶向下学习,review code是最后一步
                * install
                    *_ 获知系统依赖性组件,而这是系统设计和实现的基础
                    *_ 安装目录也能提供使用/运行的基本信息
                    *_ 系统提供了那些工具方便我们使用
                * run
                    *_ 关注命令行和配置文件
                    *_ 提供关键信息:系统提供哪些能力/系统如何运行
                * 原理研究 关键在于"系统性"
                    *_ 关键特性的基本实现原理
                    * 优缺点对比分析
                        *_ 了解优缺点才算基本掌握
                        *_ 了解优缺点才能做出合理选择
                    *_ 通读项目设计文档
                    *_ 阅读互联网上既有文档
                    *_ demo验证
                * test
                    *_ 实际项目使用,必须先测试
                    *_ 测试一定在原理研究后,不然可能配置不对,达不到验证效果
                * review code
                    *_ 不读所有source code
                    *[#lightyellow] 核心code
                        *_ 如Redis的RDB快照
                        *_ Nginx多Reactor模型
                        *_ Disruptor使用volatile和CAS做无锁设计
                        *_ Netty的Zero-Copy
                    *_ 写个Demo,调试查看调用栈
                *_ 时间分配 时间不够的话,不用test/review code
        *[#lightblue] 架构师成长之路
            *[#lightgreen] 架构师内功
                *_ 判断力 判断系统复杂度在哪里
                *_ 执行力 使用合适的方案解决复杂度问题
                *_ 创新力 能够创造新的方法解决复杂度问题
            *[#lightgreen] 架构师内功来源
                *_ 经验
                *_ 视野
                *_ 思考
            *[#lightgreen] 工程师
                *_ 在别人的指导下开发
                * 基础技能积累
                    *_ 语言
                    *_ 编程工具的使用
                    *_ 业务基本流程
            *[#lightgreen] 高级工程师
                *_ 独立开发
                * 积累方案设计经验
                    *_ 表设计经验
                    *_ 接口设计经验
                    *_ 缓存设计经验
                    *_ 业务流程设计经验
                * 与工程师的差异
                    *_ 深度 工程师知道how,高级工程师知道why
                    *_ 理论 数据库范式/设计模式/solid设计原则/缓存设计理论(穿透/雪崩/热点)
            *[#lightgreen] 技术专家
                *_ 某个领域的专家
                * 与高级工程师的差异
                    *_ 高级工程师在已有框架下完成设计,技术专家修改/扩展/优化框架
                    *_ 广度 如多线程/JVM/Netty/ES/Redis/MySQL
            *[#lightgreen] 初级架构师
                *_ 独立完成系统架构设计
                * 与技术专家的差异
                    *_ 基于架构设计方法论,专家基于经验
            *[#lightgreen] 中级架构师
                *_ 完成复杂系统架构设计
                * 与初级架构师的差异
                    *_ 系统复杂度不同
                    * 技术深度
                        *_ CAP/BASE是异地多活理论基础\nPaxos是分布式一致性基础算法\n2PC/3PC是分布式事务基础算法
                    * 技术理论
                        *_ Kafka磁盘顺序写\nDisruptor结合CPU预读取机制/缓存行/无锁设计\nStorm高效异或确认机制\nFlink的分布式快照算法
                        *_ 与技术专家的差异就在于理解的深刻程度
            *[#lightgreen] 高级架构师
                * 创造新的架构模式
                    *_ 复杂业务场景
                    *_ 足够强大的技术团队
                    *_ 不满足于现状的态度
                    *_ 尊重技术价值的文化
        *[#lightblue] 架构师必读书单
            *[#lightgreen] 成长篇
                *_ 异类
                *_ 随机漫步的傻瓜
                *_ 一万小时天才理论
                *_ 情商
                *_ 优秀到不能被忽视
                *_ 影响力大师
                *_ 羊皮卷--选择的力量
            *[#lightgreen] 技术篇
                *_ 运行环境/核心语言/基础知识/成熟技术
                *_ UNIX编程艺术
                *_ UNIX网络编程
                *_ UNIX环境高级编程
                *_ Linux系统编程
                *_ TCP/IP详解
                *_ 算法之美
                *_ 算法设计与应用
                *_ Java编程思想
                *_ 深入理解Java虚拟机
                *_ C++ primer
            *[#lightgreen] 业务篇
                *_ 增长黑客
                *_ 需求
                *_ 淘宝十年产品事
                *_ 定位
                *_ 保洁制胜战略
                *_ 算法设计与应用
                *_ 算法设计与应用
                *_ 算法设计与应用
        *[#lightblue] 单服务器高性能模式性能对比
            *[#lightgreen] 对比模式
                *_ iterative
                *_ forking(PPC模式)
                *_ preforked(prefork模式)
                *_ threaded(TPC模式)
                *_ preThreaded(pre-thread模式)
                *_ poll
                *_ epoll(Reactor模式)
            *[#lightgreen] 横向看对比
                *_ 并发2k内 prefork/pre-thread/epoll性能接近
                *_ 并发8k以上 只有pre-thread/epoll能继续运行,但性能下降,epoll下降更平缓
                *_ pre-thread的性能大概是forking的4倍,说明进程的消耗大概是线程的4倍
            *[#lightgreen] 纵向看转折
                *_ 并发11k时 pre-thread性能从2200下降到970,推测线程切换消耗超过了IO处理
                *_ poll模式随着并发数增多稳定下降,因为需要遍历的描述符越多,其性能越低(select模式类似)
                *_ 并发超过10k时,epoll性能稳定下降
                *_ 所以Nginx为了支持10K+并发,多进程Reactor模式
                *_ Redis单进程Reactor模式,是因为内部访问,并发一般不会超过10k
        *[#lightblue] 扒一扒中台皇帝的外衣
            *_ 中台的价值 提炼业务共性需求,减少重复造轮子
            *[#lightgreen] 实际痛点
                *_ 业务部门并不独立 大业务权重大
                *_ 中台并不总能提炼共性需求 业务发展中,中台和业务方存在不同诉求
                *_ 中台的轮子会不断变化
                *_ 中台是某类业务的中台,不是所有业务的中台
        *[#lightgreen] 效果
            *_ 业务部门并不清楚中台提供的能力
            *_ 中台所谓的"快",并没有严谨的衡量 开发时间少,沟通/联调时间多
            *_ 中台是大公司业务发展的阶段,小公司或者初创业务并不适合
        *[#lightblue] ChatGPT来临,架构师何去何从
            *[#lightgreen] 相对缺陷
                *_ 样本越小,训练效果越差
                *_ 数据无法及时更新
                *_ 历史数据对未来影响很大
            *[#lightgreen] 业务篇
                *_ 业务需求本身的差异性无法训练
                *_ 架构设计中的判断标准无法标准化
                *_ 技术在不断演进
                *_ 架构师需要创新能力
            *_ 适合替代标准化常规工作
    *[#pink] 7结课测试
    *[#pink] 8结束语
        *_ 10000小时理论 10年每年1000小时,每天3小事,最难的是坚持
        *_ 坚持梦想
        *_ 坚持学习
        *_ 坚持输出
    *[#pink] 9旅程再启
        *[#lightblue] 接口类设计技巧
            *[#lightgreen] 微服务特点
                *_ 服务分布式
                *_ 数据分布式
            *[#lightgreen] BFF(Backed For Frontend)
                *[#lightgrey] 应用场景
                    *_ 接口聚合
                    *_ 多端适配
                    *_ 接口兼容
                *[#lightgrey] 落地经验
                    * 前端负责开发
                        * 好处
                            *_ 最清楚前端需求
                            *_ Node.js统一技术栈
                        * 坏处
                            *_ 前端干后端,可能不擅长
                            *_ BFF与后端技术栈不同,DevOps有额外工作量
                    * 后端负责开发 优缺点和前端开发相反
                *[#lightgrey] 什么场景适用
                    *_ 访问量大,复杂.比如一/二级页面(首页/导航)
            *[#lightgreen] GraphQL API查询语言规范 Facebook2015开源
                *_ 客户端指定需要数据,减少数据传输
                *_ 可以从多个数据源获取数据
                *_ GraphQL是API接口规范,BFF是API接口架构
            *[#lightgreen] 接口循环调用如何应对
                * 梳理调用链(复杂,实践效率低,定位时间长)
                * 请求唯一标识(影响性能,需要保存一段时间内大请求ID和状态)
        *[#lightblue] 分布式事务
            *[#lightgreen] 业务级分别式事务 区分数据库层面分布式事务
                * 本地事务消息
                    *_ 故障恢复和人工订正方便
                    *_ 异常处理分支多,整体逻辑复杂
                * MQ事务消息
                    *_ 保证本地分支事务和下游消息发送事务的一致性
                    *_ 但不保证下游消费结果和上游事务的一致性,所以需要做好消费重试
                * TCC try/confirm/cancel
                    *_ 对业务侵入大,设计复杂
                    *_ 不依赖数据库
                    *_ 可以跨存储系统,跨应用资源管理
                * SAGA sequence of atomic transaction for global applications
                    *_ 本质上是一种补偿协议
                    *_ 将长事务分解为一系列子事务
                    *_ 每个子事务有补偿事务
                * Apache Seata 阿里开源的分布式事务解决方案
        *[#lightblue] 全局幂等
        *[#lightblue] 异地多活成熟架构模式
        *[#lightblue] 云原生时代架构师进化之道
        *[#lightblue] 大模型时代架构师进化之道
        *[#lightblue] 架构演进的技巧和原则
        *[#lightblue] 架构师面试和晋升
@endmindmap