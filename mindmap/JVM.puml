@startmindmap
*[#orange] JVM
    *[#pink] 1基本原理
        *[#lightblue] 代码如何运行
            *[#lightgreen] 为何需要JVM
                *_ 提升移植性
                * 提供托管环境
                    *_ 内存管理/垃圾回收
                    *_ 数组越界/动态类型/安全权限等动态检测
            *[#lightgreen] JVM如何运行字节码
                * JVM运行时内存区域
                    *[#lightyellow] 线程共享
                        *_ 方法区,(class文件先加载至此)
                        *_ 堆
                    *[#lightyellow] 线程私有
                        *_ PC寄存器(存放各个线程执行位置)
                        *_ Java方法栈
                        *_ 本地方法(用C++写的native方法)栈
                * 运行细节
                    *_ 源码编译为opCode(大小为一字节,所以又称字节码),字节码被JVM转换为机器码
                    *_ 每调用一个方法,方法栈中生成一个栈帧(存放局部变量以及字节码的操作数,大小是提前计算好,不要求栈帧在内存空间里连续分布)
                    *_ 退出方法,弹出栈帧,并舍弃
                    * 字节码转为机器码的两种方式
                        *_ 解释执行 无需等待编译
                        *_ JIT(JustInTime compilation)即时编译 运行更快(速度可能超过C++)
                    * 实际是混合运行:默认解释,热点JIT
                    * JIT编译器 C1(client,编译时间短)/C2(server,编译时间长但更快)/Graal
                    * 热点先C1再C2
        *[#lightblue] 基本类型
            *_ boolean 1字节
            *_ byte 1字节
            *_ short 2字节
            *_ char 2字节
            *_ int 4个字节
            *_ long 8个字节
            *_ float 4个字节 有+0.0和-0.0,且相等,有范围是NaN(Not a Number)
            *_ double 8个字节 同上
            *_ 栈帧上除了long和double,实际都是和int一样,4个字节
        *[#lightblue] 如何加载Java类
            *[#lightgreen] 加载 类加载器加载类(字节流,可以是class文件,也可是网络获取) Parent委派
            *[#lightgreen] 链接
                *_ 验证
                * 准备
                    *_ 静态字段分配内存/初始化
                    *_ 类层次相关数据结构:例如实现虚方法的动态绑定的方法表
                * 解析
                    *_ 符号引用转为实际引用(可能触发其他类加载)
                    *_ 静态字段分配内存/初始化
            *[#lightgreen] 初始化
                *_ 静态方法
                *_ 常量标记+赋值
        *[#lightblue] 如何执行方法调用上
            *[#lightgreen] 重载与重写
                * 重载:方法名相同,参数不同
                    *_ 不考虑对基本类型自动装拆箱以及可变长参数选取
                    *_ 允许自动装拆箱,但不允许可变长参数选取
                    *_ 允许自动装拆箱以及可变长参数选取
                    *_ 多个方法匹配,选取最贴切的,重点考虑参数类型的继承关系(子类参数认为更贴切)
                * 重写:方法名相同,参数也相同(父子类)
                    *_ 静态情况下,子类隐藏了父类方法
                    *_ 非静态&&非私有,子类重写了父类方法
            *[#lightgreen] JVM调用
                *_ invokeStatic(静态方法)
                *_ invokeSpecial(私有方法,构造器;super调用父类方法;接口default方法)
                *_ invokeVirtual(非私有方法,并且这些方法支持多态)
                *_ invokeInterface(接口方法,因为接口有多个实现类,调用需搜索具体实现类,效率比invokeVirtual低)
                *_ invokeDynamic(支持JVM上动态类型语言,lambda表达式和方法引用)
        *[#lightblue] 如何执行方法调用下
            *_ 静态绑定实际引用是方法指针,动态绑定是方法索引表
            *[#lightgreen] 优化
                * 内联缓存(inlining cache)
                    *_ 单态monomorphic
                    *_ 多态polymorphic,二态bimorphic是其中一种
                    *_ 超多态megamorphic
                *_ 方法内联(method inlining)
        *[#lightblue] 如何处理异常
            *_ 在编译生成的字节码中,每个方法都附带一个异常表.
            *_ 异常表中的每一个条目代表一个异常处理器,并且由from指针、to指针、target指针以及所捕获的异常类型构成
            *_ 这些指针的值是字节码索引(bytecode index，bci),用以定位字节码
            *_ from指针和to指针标示了该异常处理器所监控的范围,例如try代码块所覆盖的范围
            *_ target指针则指向异常处理器的起始位置,例如catch代码块的起始位置
            *_ JVM复制finally代码块的内容,分别放在try-catch代码块所有正常执行路径以及异常执行路径的出口中
            *_ 如果catch处理里有异常,抛出的是处理的异常
            *_ Suppressed异常:允许异常上附带异常信息
            *_ try with resource
            *_ catch代码块中捕获多种异常,用|分隔
        *[#lightblue] 如何实现反射
            *[#lightgreen] 实现
                *_ 本地实现和委派实现
                *_ 第一次调用委派实现,委派本地实现
                *_ 本地实现通过JVM内部调用目标方法
                *_ 动态实现通过生成字节码调用内部方法(比本地实现快20倍,因为没有java到c++再到java的切换,但字节码生成很耗时)
                *_ inflation机制在调用次数达到阈值切换委派实现为动态实现
            *[#lightgreen] 开销
                *_ 变长参数导致的object数组
                *_ 基本类型的自动装箱拆箱
                *_ 方法内联
            *[#lightgreen] 优化
                *_ 扩大Integer缓存范围
                *_ 循环外构造参数数组直接传递给反射调用(但可能破坏逃逸分析,使得性能反而下降)
                *_ 提高JVM关于每个调用能够记录的类型数目(默认2)
                *_ 误扰Method.invoke方法的类型profile,会导致性能下降
        *[#lightblue] 如何实现invokeDynamic上
            *[#lightgreen] 方法句柄MethodHandle
                *_ 强类型,能够直接被执行的引用
                *_ 类型由入参类型和返回类型,唯一确定
                *_ 通过MethodHandles.lookup类完成
                *_ 创建时检查权限,此后不再检查,所以相比重复检查的反射,性能会更好
                *_ 权限检查不在MethodHandle的创建位置,在lookup对象的创建位置
                *_ 通过invokeExact(入参类型与声明严格匹配,严格到子类不能传入父类的声明)以及invoke来调用
                *_ 和反射一样,都是间接调用,同样会面对无法内联的问题
        *[#lightblue] 如何实现invokeDynamic下
            *_ 抽象出调用点的概念,并调用该调用点链接的方法句柄
            *_ 第一次生成并绑定调用点,后续直接调用已经绑定的方法
            *_ 没有捕获的lambda,始终返回同一个适配器类的实例,捕获的每次都是新的实例
            *_ 所以应该尽可能使用非捕获式,不过捕获式也可能借助逃逸分析,避免实际新建适配器类实例的操作
        *[#lightblue] 对象的内存布局TODO
            *[#lightgreen] 新建object方式
                * new 构造方法
                    *_ 无则自动添加无参构造器
                    *_ 子类需要先调用父类构造器
                    *_ 父类无无参构造器,子类需要显示调用父类带参数构造器
                *_ 反射机制 构造方法
                *_ clone 复制已有数据
                *_ 反序列化 复制已有数据
                *_ Unsafe.allocateInstance方法 不初始化实例字段
            *[#lightgreen] object内存布局
                *[#lightyellow] 对象头
                    *_ 标记字段 64位:如hash码,gc信息,锁信息
                    * 类型指针 64位:指向该对象的类
                        * 压缩指针
                            *_ 64位压缩到32位
                            *_ 压缩指针原理:大部分类型都超过1byte,以2byte为最小单位组织内存寻址
                            *_ 内存对齐 默认为8,即至少需要8个字节,少了则浪费
                * 字段重排列
                    *_ 排列方法:如果一个field占据n个字节,偏移量要是n的倍数;子类继承字段的偏移量和父类对应字段的偏移量一致
                    *_ false sharing问题:两个字段恰好在一个缓存行,对一个字段操作导致整行写回
                    *_ @Contented注释 处在独立的缓存行,有空间浪费
        *[#lightblue] 垃圾回收上
            *[#lightgreen] 如何确认什么需要回收
                * 引用计数法
                    *_ 引用指向某一对象,该对象引用计数+1;引用被指向其他值,该对象计数-1
                    *_ 需要额外空间计数;无法处理循环引用的对象
                * 可达性分析
                    *_ GC roots可达对象放入live set,此过程被称为标记Mark
                    *[#lightyellow] GC roots
                        *_ Java 方法栈桢中的局部变量
                        *_ 已加载类的静态变量
                        *_ JNI handles
                        *_ 已启动且未停止的Java线程
                    *_ 误标:问题不大,下次回收即可
                    *_ 漏标:问题很大,可能导致JVM崩溃
            *[#lightgreen] stop the world
                *_ 通过safepoint实现,等所有线程都到safepoint
                *_ 对解释执行,字节码与字节码之间皆可作为安全点
                *_ 对于机器码,HotSpot虚拟机的做法便是在生成代码的方法出口以及非计数循环的循环回边(back-edge)处插入安全点检测
                *_ 如果长时间不进行safepoint检测,则gc等待safepoint时间变长
                *_ 如果频繁进行safepoint检测,有额外开销
            *[#lightgreen] 回收方式
                *_ sweep:简单;有内存碎片+分配效率低(连续可以类似数组,碎片只能链表化)
                *_ compact:无碎片;开销大
                * copy:无碎片;内存使用效率低
                    *_ 内存分成两个部分,用from,to两个指针维护
                    *_ 使用from分配内存
                    *_ 将from复制到to的内存区域
                    *_ 交换from和to的指针内容
        *[#lightblue] 垃圾回收下
            *_ 大部分对象只活很少时间,少部分幸存对象会活很久
            *[#lightgreen] TLAB(Thread Local Allocation Buffer)
                *_ 每个线程向JVM申请一段连续内存,私有,该操作加锁
                *_ 维护两个指针,一个头一个尾,new通过指针加法实现,加法后如果超过尾,则重新申请
            *_ 新生在Eden;minorGC存活去survivor
            *[#lightgreen] CardTable
                *_ 512字节,如果有指向新生代的引用,该卡dirty
                *_ minorGC,不需要扫描全部老年代,只扫描dirty cards,加入GC roots,扫完脏卡标志清0
                *_ 需要截获所有引用型实例变量的写操作,解释型好实现
                *_ 机器码需要写屏障,有额外开销,但是能加大MinorGC吞吐率
                * 可能有false sharing问题
                    *_ G1维护了一个脏卡队列,更新时写入本地队列而不是全局卡表,定期刷新队列到全局卡表left side
    *[#pink] 2高效编译
        *[#lightblue] 常用工具介绍
        *[#lightblue] 内存模型
            *[#lightgreen] happens-before
                *_ 同一线程中的顺序性,前面操作结果对后面可见
                *_ volatile的写操作对后续读操作可见
                *_ 传递性 A before B & B before C => A before C
                *_ Monitor中lock的解锁对后续加锁可见
                *_ 线程start规则 线程A中start线程B,B能看见A在startB之前的操作结果
                *_ 线程join规则 线程A中等待子线程B完成(join),A能看到B的操作结果
            *[#lightgreen] 实现(Memory Barrier)
                *_ 插入相应的Memory Barrier
                *_ 对X86,读读/读写/写写是空指令,写读有具体指令
            *_ volatile 强制刷新缓存
            *_ final写操作后插入写写屏障,防止重排序至final字段写之前
            *_ safe publication:对象被完全初始化后,其他线程才能访问它;实现static/volatile/final/lock
        *[#lightblue] 如何实现synchronized
            *_ 字节码monitorenter/monitorexit来持有/释放monitor对象
            *_ monitor可以和对象一起创建/销毁,由c++ObjectMonitor实现
            *_ monitor由操作系统mutex lock实现互斥,会导致内核态/用户态切换,cost高
            *_ 对象实例在内存中的三部分:对象头/实例数据/对齐填充
            *_ 对象头由mark word/指向类的指针/数组长度三部分组成
            *[#lightgreen] mark word64bit
                *_ 无锁 25bit unused+31bit hashCode+1bit unused+4bit age分代年龄+1bit 是否偏向锁(0)+2bit锁标识位(01)
                *_ 偏向锁 54bit 线程ID+2bit Epoch+1bit unused+4bit age分代年龄+1bit 是否偏向锁(1)+2bit锁标识位(01)
                *_ 轻量级锁 62bit指向轻量级锁的指针+2bit锁标识位(00)
                *_ 重量级锁 62bit指向重量级锁的指针+2bit锁标识位(10)
                *_ GC标记 62bit空+2bit锁标识位(11)
            *[#lightgreen] Epoch
                *_ 偏向锁有竞争时会撤销,撤销麻烦,需要持有线程到达安全点,再替换为轻量锁
                *_ epoch最新值放在类的元数据里,对象头存储当前epoch
                *_ 如果不匹配说明(以类为维度)锁竞争激烈
            *_ 偏向锁优化同一线程多次申请同一个锁的竞争
            *_ 大量线程竞争同一资源会导致偏向锁频繁被撤销,可以通过调整JVM参数禁用偏向锁或使用重量级锁
            *_ 偏向锁竞争先用CAS获取锁,若失败升级为轻量级锁
            *_ 轻量级锁适合不存在长时间竞争的场景,可以调整JVM参数调整是否关闭自旋
            *_ 自旋尝试多次仍无法获取锁,升级到重量级锁,未抢到锁的线程会阻塞进入wait_set
            *_ 动态编译实现锁粗化/锁消除
            *_ 编码可以细化锁粒度
        *[#lightblue] 语法糖与编译器
            *[#lightgreen] 自动拆装箱
                *_ Integer.valueOf/intValue
            *[#lightgreen] 范型
                *_ 选取该泛型所能指代的所有类中层次最高的那个,作为替换泛型的类
            *[#lightgreen] 桥接方法
                *_ 重写了父类的同名同方法描述符的方法
        *[#lightblue] 即时编译上
            *[#lightgreen] 编译器分类
                *_ C1 client
                *_ C2 server(实现语言C++)
                *_ Graal(实现语言Java,替换C2,17成为默认)
            *[#lightgreen] 分层编译
                * 层数
                    *_ 解释执行
                    *_ 不带profiling的C1(终止状态)
                    *_ 仅带方法次数调用和循环回边计数profiling的C1
                    *_ 带所有profiling的C1
                    *_ C2(终止状态)
                *_ 性能:C2>C1(1)>C1(2)>C1(3)
                *_ C2性能高于C1 30%,C1(2)又高于C1(3) 30%,主要是profiling有额外开销
            *[#lightgreen] 即时编译触发
                *_ 调用次数和回边执行次数
                * 动态调整阈值
                    *_ 系数s=queue_size_X/(TierXLoadFeedback*compiler_count_X)+1
                    *_ 其中X是执行层次,可取3或者4
                    *_ queue_size_X是执行层次为X的待编译方法的数目
                    *_ TierXLoadFeedback是预设好的参数,其中Tier3LoadFeedback为5,Tier4LoadFeedback为3
                    *_ compiler_count_X是层次X的编译线程数目
            *[#lightgreen] OSR(On-Stack-Replacement)编译
                *_ 循环回边计数器
                *_ 解决单次调用包含热循环的性能优化问题
        *[#lightblue] 即时编译下
            *[#lightgreen] profiling
                *_ branch profile
                *_ receiver type profile
                *_ 解释过程没有profile,C1后,JVM认为该方法有可能被C2编译,方才在该方法的C1代码中收集这些profile
                *_ C2可以根据收集得到的数据进行猜测,假设接下来的执行同样会按照所收集的profile进行,从而作出比较激进的优化
            *[#lightgreen] 基于分支的profiling
                *_ 未执行过的分支被剪枝
            *[#lightgreen] 基于类型的profiling
                *_ compiler假设动态类型只有profile中的那几个
            *[#lightgreen] 去优化
                *_ 退回解释执行
                *_ 插入陷阱(在被剪枝的分支)进行去优化
                *_ 根据去优化的原因决定是否保留机器码和何时重新编译Java方法
        *[#lightblue] 即时编译器的中间表达形式
            *[#lightgreen] IR(Intermediate Representation)
                *_ java字节码
                *_ 即时编译器会将Java字节码转换成SSA(Static Single Assignment) IR
            *[#lightgreen] sea-of-nodes
                *_ 节点调度
                *_ 内存依赖
            *[#lightgreen] GVN(Global Value Numbering)
                *_ IR图上的公共子表达式消除(Common Subexpression Elimination,CSE)
        *[#lightblue] 字节码(基础篇)
            *[#lightgreen] 加载常量
                *_ iconst [-1,5]
                *_ bipush [-128,127]
                *_ sipush [-32768,32767]
                *_ ldc any int value
                *_ fconst any float value
                *_ dconst any double value
                *_ aconst reference
            *[#lightgreen] 操作数栈
                *_ dup 复制栈顶
                *_ pop 弹出栈顶
                *_ swap 交换栈顶
            *[#lightgreen] 局部变量区访问
                *_ iload 加载(至操作数栈)int
                *_ istore 存储(回局部变量数组)int
                *_ aload reference加载
                *_ astore reference存储
                *_ iinc 增加,常用于循环自增量更新
            *[#lightgreen] Java相关
                *_ new
                *_ instanceof
                *_ checkcast
                *_ athrow
                *_ monitorenter
                *_ monitorexit
            *[#lightgreen] 字段访问
                *_ getstatic
                *_ putstatic
                *_ getfield
                *_ putfield
            *[#lightgreen] 方法调用
                *_ invokestatic
                *_ invokevirtual
                *_ invokespecial
                *_ invokeinterface
                *_ invokedynamic
            *[#lightgreen] 数组相关
                *_ newarray
                *_ anewarray
                *_ multianewarray
                *_ arraylength
            *[#lightgreen] 控制流
                *_ goto
                *_ tableswitch
                *_ lookupswitch
                *_ 条件跳转
                *_ 返回
            *[#lightgreen] 计算
        *[#lightblue] 方法内联上
            *_ 在编译过程中,将目标方法的方法体纳入编译范围之中,并取代原方法调用的优化手段
            *[#lightgreen] 优势
                *_ 消除调用本身带来的性能开销
                *_ 触发更多优化
            *[#lightgreen] 过程
                *_ 解析字节码
                *_ 生成IR图
                *_ 内联目标方法的IR图到调用着方法的IR图里
            *[#lightgreen] 属性
                *_ 内联越多,性能越高
                *_ 内联越多,编译时间越长
                *_ 生成机器码越长,越容易填满Code Cache,导致即时编译被关闭
                * 内联规则
                    *_ 强制内联
                    *_ 强制不内联
                    *_ 方法调用层数
                    *_ 程序路径的热度
                    *_ 目标方法的调用次数和大小
                    *_ 当前IR图的大小
        *[#lightblue] 方法内联下
        *[#lightblue] hotspot虚拟机的intrinsic
        *[#lightblue] 逃逸分析
    *[#pink] 3代码优化
        *[#lightblue] 字段访问
            *[#lightgreen] 逃逸分析
                *_ 锁消除
                *_ 栈上分配
                * 标量替换
                    *_ 对象拆散为字段
                    *_ 替换对象字段访问为局部变量访问
            *[#lightgreen] 字段读取优化
                *_ 缓存字段存储节点的值
                *_ 替换字段读取节点为缓存值
                *_ 缓存值失效时采取保守策略
                *_ 优化实例字段和静态字段访问
            *[#lightgreen] 字段存储优化
                *_ 消除冗余的存储节点
                *_ 消除冗余存储操作
                * 冗余存储操作消除条件
                    *_ 两次存储间没有读取
                    *_ 被标记为volatile字段
            *[#lightgreen] 死代码消除
                *_ 死存储消除
                *_ 部分死存储消除(if/else分支)
                *_ 不可达分支消除
        *[#lightblue] 循环
            *_ 循环无关code外提
            *_ 循环展开
            *_ 循环判断外提
            *_ 循环剥离
        *[#lightblue] 向量化
            *_ 向量化优化借助CPU的SIMD指令(单条指令控制多组数据的运算,cpu指令级别并行)
            *_ HotSpot虚拟机使用HotSpot intrinsic和自动向量化两种方式
            *_ 自动向量化的自适配性取决于循环回边的执行次数和方法的执行次数
        *[#lightblue] 注解处理器
            *_ 修改已有的java源文件或生成新的java源文件
            * 原理
                *_ 将源文件解析为抽象语法树
                *_ 调用已经注册的注解处理器
                *_ 生成字节码
            *_ Processor接口;抽象类AbstractProcessor
            *[#lightgreen] 注解处理器
        *[#lightblue] 基准测试框架JMH上
        *[#lightblue] 基准测试框架JMH下
        *[#lightblue] Java虚拟机的监控及诊断工具(命令行篇)
        *[#lightblue] Java虚拟机的监控及诊断工具(GUI篇)
        *[#lightblue] JNI运行机制
        *[#lightblue] JavaAgent与字节码注入
left side
    *[#pink] 4黑科技
        *[#lightblue] Graal:用java编译java
        *[#lightblue] Truffle:语言实现框架
        *[#lightblue] SubstrateVm:AOT编译框架
@endmindmap